[{"content":"1.1设备树是什么 device tree 设备树 dts device tree source 设备树源文件 dtc device tree compiler 设备树编译/反编译/调试工具 dtb device tree blob 设备树二进制文件 1.2设备树如何工作 1.2.1编译阶段 dtc :用于编译dts文件为dtb文件\ndtb :用于kernel去使用设备树\n1 2 3 4 5 .dts (源文件) ↓ dtc编译 .dtb (二进制Blob) ↓ 嵌入内核或单独加载 启动时加载到内存 1.2.2引导阶段 目的：加载到内存\n1 2 3 4 5 Bootloader（如U-Boot）加载设备树 // 1. 从存储设备读取dtb // 2. 修正地址（relocation） // 3. 传递给内核 // 4. 跳转到内核入口 1.2.3内核初始化阶段 加载到内核完后，需要将设备树进行解析\n1 2 3 4 5 6 7 8 9 10 11 12 // arch/arm/kernel/setup.c void __init setup_arch(char **cmdline_p) { // 1. 早期设备树扫描 early_init_dt_scan_nodes(); // 2. 解析内存信息 early_init_dt_scan_memory(); // 3. 解析chosen节点（bootargs等） of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line); } 展开设备树结构\n1 2 3 4 5 6 7 8 9 10 11 // drivers/of/fdt.c void __init unflatten_device_tree(void) { // 将平面设备树转换为树形结构 __unflatten_device_tree(initial_boot_params, \u0026amp;of_root, \u0026amp;of_allnodes); // 最终生成的结构： // of_root -\u0026gt; 根节点 // of_allnodes -\u0026gt; 所有节点的链表 } 这样就得到了设备树数据，后续就需要驱动去匹配了。\n1.3驱动匹配设备树 这里需要介绍几个核心的结构体：\n1.3.1相关数据结构 1.3.1.1设备树相关结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 设备树节点内核表示 struct device_node { const char *name; // 节点名称 const char *type; // 设备类型 phandle phandle; // 句柄 const char *full_name; // 完整路径名 struct property *properties; // 属性链表 struct device_node *parent; // 父节点 struct device_node *child; // 子节点 struct device_node *sibling; // 兄弟节点 const void *data; // 设备特定数据 }; // 设备树属性 struct property { char *name; // 属性名 int length; // 值长度 void *value; // 属性值 struct property *next; // 下一个属性 unsigned long _flags; // 内部标志 }; 1.3.1.2平台设备结构 1 2 3 4 5 6 7 8 9 10 11 12 13 // 由设备树节点创建的platform_device struct platform_device { const char *name; // 设备名称 int id; // 设备ID struct device dev; // 基础设备结构 u32 num_resources; // 资源数量 struct resource *resource; // 资源数组 const struct platform_device_id *id_entry; // 设备树相关 struct device_node *of_node; // 对应的设备树节点 struct irq_domain *irq_domain; }; 1.3.1.3驱动匹配结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 设备树匹配表 struct of_device_id { char name[32]; // 设备名称 char type[32]; // 设备类型 char compatible[128]; // 兼容字符串 const void *data; // 私有数据 }; // 平台驱动结构 struct platform_driver { int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); struct device_driver driver; // 基础驱动结构 const struct platform_device_id *id_table; // 设备树匹配表 const struct of_device_id *of_match_table; }; 1.3.2驱动匹配过程 1.3.2.1阶段一：设备树节点转换为设备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // drivers/of/platform.c /** * of_platform_populate() - 从设备树创建设备 */ int of_platform_populate(struct device_node *root, const struct of_device_id *matches, struct device *parent) { struct device_node *child; // 遍历设备树节点 for_each_child_of_node(root, child) { // 检查节点是否可用 if (!of_device_is_available(child)) continue; // 创建设备 of_platform_device_create_pdata(child, matches, parent, NULL); } return 0; } /** * of_platform_device_create_pdata() - 创建platform_device */ static struct platform_device *of_platform_device_create_pdata( struct device_node *np, const char *bus_id, void *platform_data, struct device *parent) { struct platform_device *pdev; // 1. 分配platform_device pdev = platform_device_alloc(\u0026#34;\u0026#34;, PLATFORM_DEVID_NONE); if (!pdev) return NULL; // 2. 设置设备树节点 pdev-\u0026gt;dev.of_node = of_node_get(np); pdev-\u0026gt;dev.parent = parent; // 3. 设置设备名称 if (bus_id) pdev-\u0026gt;name = bus_id; else pdev-\u0026gt;name = np-\u0026gt;name; // 4. 解析设备资源（内存、IRQ等） of_device_add_resource(pdev, np); // 5. 添加到系统 if (platform_device_add(pdev) != 0) { platform_device_put(pdev); return NULL; } return pdev; } 1.3.2.2阶段二：驱动注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 驱动注册示例 static struct platform_driver my_driver = { .driver = { .name = \u0026#34;my-device\u0026#34;, .owner = THIS_MODULE, .of_match_table = my_of_match, // 关键：设备树匹配表 }, .probe = my_probe, .remove = my_remove, }; // 设备树匹配表 static const struct of_device_id my_of_match[] = { { .compatible = \u0026#34;vendor,device-v1.0\u0026#34; }, { .compatible = \u0026#34;vendor,device-v2.0\u0026#34; }, { .compatible = \u0026#34;vendor,generic-device\u0026#34; }, { } // 结束标记 }; MODULE_DEVICE_TABLE(of, my_of_match); // 驱动注册 module_platform_driver(my_driver); // 展开后的注册函数 static int __init my_driver_init(void) { return platform_driver_register(\u0026amp;my_driver); } module_init(my_driver_init); 1.3.2.3阶段三：匹配执行过程 此处是内核在做的事情，具体不展开分析了。\n后续持续更新！感谢观看！\n","date":"2026-02-02T00:00:00Z","image":"https://shi1iu.github.io/p/%E8%AE%BE%E5%A4%87%E6%A0%91/beijin_hu857221033354771913.jpg","permalink":"https://shi1iu.github.io/p/%E8%AE%BE%E5%A4%87%E6%A0%91/","title":"设备树"}]
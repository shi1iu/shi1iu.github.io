[{"content":"Linux下系统调用open()的参数含义 open函数原型 1 2 3 4 5 6 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); pathname参数\n要打开的文件路径 flags参数\n这些标志使用位或运算 | 组合：\n必需标志（三选一）：\nO_RDONLY - 只读 O_WRONLY - 只写 O_RDWR - 读写 可选标志：\nO_CREAT - 文件不存在时创建 O_EXCL - 与 O_CREAT 配合使用，确保文件是新建的（原子操作） O_TRUNC - 打开时清空文件内容 O_APPEND - 追加模式 O_NONBLOCK - 非阻塞模式 O_SYNC - 同步写入（等待物理写入完成） O_CLOEXEC - 执行exec时关闭文件描述符（FD_CLOEXEC） mode参数\n仅当使用 O_CREAT 时才需要 指定新文件的权限（八进制） 示例：0644（用户rw，组r，其他r） 区分open()和fopen() 类型 简介 open() Unix下系统调用函数，操作成功返回的是文件描述符，操作失败返回的是-1 fopen() ANSIC标准中C语言库函数，在不同的系统中调用不同的内核的API，返回的是一个指向文件结构的指针 区别：open含义没有缓存，fopen函数有缓存。\n拓展补充fopen() 函数\nfopen函数原型\n1 2 #include \u0026lt;stdio.h\u0026gt; FILE *fopen(const char *pathname, const char *mode); pathname参数\n文件路径字符串 可以是相对路径或绝对路径 示例：\u0026quot;data.txt\u0026quot;, \u0026quot;/home/user/file.bin\u0026quot; mode参数\n由以下字符组合而成：\n基础模式字符：\n\u0026quot;r\u0026quot; - 只读打开文本文件（文件必须存在） \u0026quot;w\u0026quot; - 只写打开文本文件（文件存在则清空，不存在则创建） \u0026quot;a\u0026quot; - 追加打开文本文件（文件不存在则创建，写入位置在文件末尾） \u0026quot;r+\u0026quot; - 读写打开文本文件（文件必须存在） \u0026quot;w+\u0026quot; - 读写打开文本文件（文件存在则清空，不存在则创建） \u0026quot;a+\u0026quot; - 读写打开文本文件（读取从开头，写入在末尾） 二进制模式修饰符（加在基础模式后）：\n\u0026quot;b\u0026quot; - 二进制模式（Windows上重要，Linux上可省略但建议使用） \u0026quot;rb\u0026quot;, \u0026quot;wb\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;r+b\u0026quot;, \u0026quot;w+b\u0026quot;, \u0026quot;a+b\u0026quot; C11新增模式：\n\u0026quot;x\u0026quot; - 独占创建模式（类似 O_EXCL） \u0026quot;wx\u0026quot;, \u0026quot;w+x\u0026quot;, \u0026quot;wbx\u0026quot; - 如果文件存在则失败 Linux下文件访问权限格式 文件格式 八进制表示法\n1 2 3 4 5 6 # 语法：u g o # u: 所有者(user), g: 所属组(group), o: 其他人(other) 0644 # rw-r--r-- 0755 # rwxr-xr-x 0700 # rwx------ 前面的0表示八进制\n权限位对应关系\n八进制 二进制 权限 说明 0 000 \u0026mdash; 无权限 1 001 \u0026ndash;x 仅执行 2 010 -w- 仅写入 3 011 -wx 写入和执行 4 100 r\u0026ndash; 仅读取 5 101 r-x 读取和执行 6 110 rw- 读取和写入 7 111 rwx 所有权限 权限修改在程序的实现 直接修改\n1 2 3 4 5 6 7 #include \u0026lt;sys/stat.h\u0026gt; // 使用chmod()系统调用 chmod(\u0026#34;file.txt\u0026#34;, 0644); // rw-r--r-- chmod(\u0026#34;script.sh\u0026#34;, 0755); // rwxr-xr-x chmod(\u0026#34;secret.txt\u0026#34;, 0600); // rw------- chmod(\u0026#34;program\u0026#34;, 4755); // rwsr-xr-x (SetUID) umask掩码修改\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main() { mode_t old_mask = umask(0022); // 设置umask并保存原值 // 创建文件，实际权限 = 0666 \u0026amp; ~022 = 0644 creat(\u0026#34;file1.txt\u0026#34;, 0666); // 恢复原umask umask(old_mask); return 0; } 文件权限表\n权限对文件的影响\n权限 对文件的影响 r (读) 读取文件内容 w (写) 修改文件内容（需要目录写权限才能删除） x (执行) 执行文件（脚本或二进制） 权限对目录的影响\n权限 对目录的影响 r (读) 列出目录内容（ls） w (写) 在目录中创建/删除/重命名文件 x (执行) 进入目录（cd）或访问文件元数据 后续遇到权限相关问题持续更新！\n","date":"2026-02-04T00:00:00Z","image":"https://shi1iu.github.io/p/linux%E4%B8%8Bopen%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/picture_hu10052601102630067577.jpg","permalink":"https://shi1iu.github.io/p/linux%E4%B8%8Bopen%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/","title":"Linux下open()和文件权限问题"},{"content":"设备树是什么 device tree 设备树 dts device tree source 设备树源文件 dtc device tree compiler 设备树编译/反编译/调试工具 dtb device tree blob 设备树二进制文件 设备树如何工作 编译阶段 dtc :用于编译dts文件为dtb文件\ndtb :用于kernel去使用设备树\n1 2 3 4 5 .dts (源文件) ↓ dtc编译 .dtb (二进制Blob) ↓ 嵌入内核或单独加载 启动时加载到内存 引导阶段 目的：加载到内存\n1 2 3 4 5 Bootloader（如U-Boot）加载设备树 // 1. 从存储设备读取dtb // 2. 修正地址（relocation） // 3. 传递给内核 // 4. 跳转到内核入口 内核初始化阶段 加载到内核完后，需要将设备树进行解析\n1 2 3 4 5 6 7 8 9 10 11 12 // arch/arm/kernel/setup.c void __init setup_arch(char **cmdline_p) { // 1. 早期设备树扫描 early_init_dt_scan_nodes(); // 2. 解析内存信息 early_init_dt_scan_memory(); // 3. 解析chosen节点（bootargs等） of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line); } 展开设备树结构\n1 2 3 4 5 6 7 8 9 10 11 // drivers/of/fdt.c void __init unflatten_device_tree(void) { // 将平面设备树转换为树形结构 __unflatten_device_tree(initial_boot_params, \u0026amp;of_root, \u0026amp;of_allnodes); // 最终生成的结构： // of_root -\u0026gt; 根节点 // of_allnodes -\u0026gt; 所有节点的链表 } 这样就得到了设备树数据，后续就需要驱动去匹配了。\n驱动匹配设备树 这里需要介绍几个核心的结构体：\n相关数据结构 设备树相关结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 设备树节点内核表示 struct device_node { const char *name; // 节点名称 const char *type; // 设备类型 phandle phandle; // 句柄 const char *full_name; // 完整路径名 struct property *properties; // 属性链表 struct device_node *parent; // 父节点 struct device_node *child; // 子节点 struct device_node *sibling; // 兄弟节点 const void *data; // 设备特定数据 }; // 设备树属性 struct property { char *name; // 属性名 int length; // 值长度 void *value; // 属性值 struct property *next; // 下一个属性 unsigned long _flags; // 内部标志 }; 平台设备结构 1 2 3 4 5 6 7 8 9 10 11 12 13 // 由设备树节点创建的platform_device struct platform_device { const char *name; // 设备名称 int id; // 设备ID struct device dev; // 基础设备结构 u32 num_resources; // 资源数量 struct resource *resource; // 资源数组 const struct platform_device_id *id_entry; // 设备树相关 struct device_node *of_node; // 对应的设备树节点 struct irq_domain *irq_domain; }; 驱动匹配结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 设备树匹配表 struct of_device_id { char name[32]; // 设备名称 char type[32]; // 设备类型 char compatible[128]; // 兼容字符串 const void *data; // 私有数据 }; // 平台驱动结构 struct platform_driver { int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); struct device_driver driver; // 基础驱动结构 const struct platform_device_id *id_table; // 设备树匹配表 const struct of_device_id *of_match_table; }; 驱动匹配过程 阶段一：设备树节点转换为设备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // drivers/of/platform.c /** * of_platform_populate() - 从设备树创建设备 */ int of_platform_populate(struct device_node *root, const struct of_device_id *matches, struct device *parent) { struct device_node *child; // 遍历设备树节点 for_each_child_of_node(root, child) { // 检查节点是否可用 if (!of_device_is_available(child)) continue; // 创建设备 of_platform_device_create_pdata(child, matches, parent, NULL); } return 0; } /** * of_platform_device_create_pdata() - 创建platform_device */ static struct platform_device *of_platform_device_create_pdata( struct device_node *np, const char *bus_id, void *platform_data, struct device *parent) { struct platform_device *pdev; // 1. 分配platform_device pdev = platform_device_alloc(\u0026#34;\u0026#34;, PLATFORM_DEVID_NONE); if (!pdev) return NULL; // 2. 设置设备树节点 pdev-\u0026gt;dev.of_node = of_node_get(np); pdev-\u0026gt;dev.parent = parent; // 3. 设置设备名称 if (bus_id) pdev-\u0026gt;name = bus_id; else pdev-\u0026gt;name = np-\u0026gt;name; // 4. 解析设备资源（内存、IRQ等） of_device_add_resource(pdev, np); // 5. 添加到系统 if (platform_device_add(pdev) != 0) { platform_device_put(pdev); return NULL; } return pdev; } 阶段二：驱动注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 驱动注册示例 static struct platform_driver my_driver = { .driver = { .name = \u0026#34;my-device\u0026#34;, .owner = THIS_MODULE, .of_match_table = my_of_match, // 关键：设备树匹配表 }, .probe = my_probe, .remove = my_remove, }; // 设备树匹配表 static const struct of_device_id my_of_match[] = { { .compatible = \u0026#34;vendor,device-v1.0\u0026#34; }, { .compatible = \u0026#34;vendor,device-v2.0\u0026#34; }, { .compatible = \u0026#34;vendor,generic-device\u0026#34; }, { } // 结束标记 }; MODULE_DEVICE_TABLE(of, my_of_match); // 驱动注册 module_platform_driver(my_driver); // 展开后的注册函数 static int __init my_driver_init(void) { return platform_driver_register(\u0026amp;my_driver); } module_init(my_driver_init); 阶段三：匹配执行过程 此处是内核在做的事情，具体不展开分析了。\n后续持续更新！感谢观看！\n","date":"2026-02-02T00:00:00Z","image":"https://shi1iu.github.io/p/%E8%AE%BE%E5%A4%87%E6%A0%91/beijin_hu857221033354771913.jpg","permalink":"https://shi1iu.github.io/p/%E8%AE%BE%E5%A4%87%E6%A0%91/","title":"设备树"}]